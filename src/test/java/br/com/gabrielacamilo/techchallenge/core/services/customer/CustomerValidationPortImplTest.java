package br.com.gabrielacamilo.techchallenge.core.services.customer;

import br.com.gabrielacamilo.techchallenge.core.domain.customer.CustomerDomain;
import br.com.gabrielacamilo.techchallenge.core.ports.customer.CustomerPersistencePort;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@ContextConfiguration(classes = {CustomerValidationPortImpl.class})
@ExtendWith(SpringExtension.class)
class CustomerValidationPortImplTest {

    @MockBean
    private CustomerPersistencePort customerPersistencePort;

    @Autowired
    private CustomerValidationPortImpl customerValidationPortImpl;

    private final String VALID_NAME = "Juan Edson Elias Porto";
    private final String VALID_EMAIL = "juan_porto@ddfnet.com.br";
    private final String VALID_CPF = "52785297849";
    private final String INVALID_EMAIL = "juan_porto";
    private final String INVALID_CPF = "11234";

    // generated by https://www.4devs.com.br/

    private CustomerDomain validCustomerDomain = new CustomerDomain(VALID_NAME, VALID_EMAIL, VALID_CPF);


    @Test
    @DisplayName("[DOMAIN][CUSTOMER VALIDATION] - should validate there are no customers with the same email or cpf")
    void testValidateCreationalBusinessRules() throws IllegalArgumentException {

        when(customerPersistencePort.getCustomerByEmail(Mockito.<String>any())).thenReturn(Optional.empty());
        when(customerPersistencePort.getCustomerByCpf(Mockito.<String>any())).thenReturn(Optional.empty());

        customerValidationPortImpl.validateCreationalBusinessRules(validCustomerDomain, customerPersistencePort);
    }

    @Test
    @DisplayName("[DOMAIN][CUSTOMER VALIDATION] - should throw an exception when there is a customer with the same email")
    void testValidateCreationalBusinessRulesCpfExists() throws IllegalArgumentException {
        when(customerPersistencePort.getCustomerByEmail(Mockito.<String>any())).thenReturn(Optional.of(Mockito.mock(CustomerDomain.class)));
        when(customerPersistencePort.getCustomerByCpf(Mockito.<String>any())).thenReturn(Optional.empty());
        assertThrows(IllegalArgumentException.class,
                () -> customerValidationPortImpl.validateCreationalBusinessRules(validCustomerDomain, customerPersistencePort));
    }

    @Test
    @DisplayName("[DOMAIN][CUSTOMER VALIDATION] - should throw an exception when there is a customer with the same cpf")
    void testValidateCreationalBusinessRuleEmailExists() throws IllegalArgumentException {
        when(customerPersistencePort.getCustomerByEmail(Mockito.<String>any())).thenReturn(Optional.empty());
        when(customerPersistencePort.getCustomerByCpf(Mockito.<String>any())).thenReturn(Optional.of(Mockito.mock(CustomerDomain.class)));

        assertThrows(IllegalArgumentException.class,
                () -> customerValidationPortImpl.validateCreationalBusinessRules(validCustomerDomain, customerPersistencePort));
    }


    @Test
    @DisplayName("[DOMAIN][CUSTOMER VALIDATION] - should validate there are no customers with the same email or cpf")
    void testValidateUpdateBusinessRules() throws IllegalArgumentException {
        when(customerPersistencePort.getCustomerByEmail(Mockito.<String>any())).thenReturn(Optional.empty());
        when(customerPersistencePort.getCustomerByCpf(Mockito.<String>any())).thenReturn(Optional.empty());

        customerValidationPortImpl.validateUpdateBusinessRules(validCustomerDomain, validCustomerDomain, customerPersistencePort);
    }

    @Test
    @DisplayName("[DOMAIN][CUSTOMER VALIDATION] - should throw an exception when trying to update cpf")
    void testValidateUpdateBusinessRulesUpdateCpf() throws IllegalArgumentException {
        when(customerPersistencePort.getCustomerByEmail(Mockito.<String>any())).thenReturn(Optional.empty());
        when(customerPersistencePort.getCustomerByCpf(Mockito.<String>any())).thenReturn(Optional.empty());

        CustomerDomain mockedCustomerDomain = mock(CustomerDomain.class);
        when(mockedCustomerDomain.getCpf()).thenReturn("123");

        assertThrows(IllegalArgumentException.class,
                () -> customerValidationPortImpl.validateUpdateBusinessRules(mockedCustomerDomain, validCustomerDomain, customerPersistencePort));
    }

    @Test
    @DisplayName("[DOMAIN][CUSTOMER VALIDATION] - should throw an exception when trying to update to an existing email")
    void testValidateUpdateBusinessRulesExistingEmail() throws IllegalArgumentException {
        when(customerPersistencePort.getCustomerByEmail(Mockito.<String>any())).thenReturn(Optional.of(Mockito.mock(CustomerDomain.class)));
        when(customerPersistencePort.getCustomerByCpf(Mockito.<String>any())).thenReturn(Optional.empty());

        CustomerDomain mockedCustomerDomain = mock(CustomerDomain.class);
        when(mockedCustomerDomain.getCpf()).thenReturn(VALID_CPF);
        when(mockedCustomerDomain.getEmail()).thenReturn("123");

        assertThrows(IllegalArgumentException.class,
                () -> customerValidationPortImpl.validateUpdateBusinessRules(mockedCustomerDomain, validCustomerDomain, customerPersistencePort));
    }

    @Test
    @DisplayName("[DOMAIN][CUSTOMER VALIDATION] - should validate delete business rules")
    void testValidateDeleteBusinessRules() throws IllegalArgumentException {
        customerValidationPortImpl.validateDeleteBusinessRules(validCustomerDomain, customerPersistencePort);
    }

    @Test
    @DisplayName("[DOMAIN][CUSTOMER VALIDATION] - should validate cpf doesnt exist")
    void testValidateUniqueCpf() throws IllegalArgumentException {
        when(customerPersistencePort.getCustomerByCpf(Mockito.<String>any())).thenReturn(Optional.empty());
        customerValidationPortImpl.validateUniqueCpf(VALID_CPF, customerPersistencePort);
    }

    @Test
    @DisplayName("[DOMAIN][CUSTOMER VALIDATION] - should throw an exception when cpf exists")
    void testValidateUniqueCpfError() throws IllegalArgumentException {
        when(customerPersistencePort.getCustomerByCpf(Mockito.<String>any())).thenReturn(Optional.of(Mockito.mock(CustomerDomain.class)));

        assertThrows(IllegalArgumentException.class,
                () -> customerValidationPortImpl.validateUniqueCpf(VALID_CPF, customerPersistencePort));

    }

    @Test
    @DisplayName("[DOMAIN][CUSTOMER VALIDATION] - should validate email doesnt exist")
    void testValidateUniqueEmail() {
        when(customerPersistencePort.getCustomerByEmail(Mockito.<String>any())).thenReturn(Optional.empty());
        customerValidationPortImpl.validateUniqueEmail(VALID_EMAIL, customerPersistencePort);
    }

    @Test
    @DisplayName("[DOMAIN][CUSTOMER VALIDATION] - should throw an exception when email exists")
    void testValidateUniqueEmailError() {
        when(customerPersistencePort.getCustomerByEmail(Mockito.<String>any())).thenReturn(Optional.of(Mockito.mock(CustomerDomain.class)));

        assertThrows(IllegalArgumentException.class,
                () -> customerValidationPortImpl.validateUniqueEmail(VALID_EMAIL, customerPersistencePort));
    }
}
